{"version":3,"sources":["../../src/animate/Animator.js"],"names":["timelines","Animator","play","instance","label","callback","loop","start","end","labelIsFunction","undefined","totalFrames","labelsMap","STOP_LABEL","LOOP_LABEL","Error","fromTo","to","currentFrame","startLabel","endLabel","stop","timeline","create","_timelines","push","gotoAndPlay","i","len","length","_internalStop","stopAll","splice","indexOf","destroy","module","exports"],"mappings":"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","file":"Animator.js","sourcesContent":["import AnimatorTimeline from './AnimatorTimeline';\n\n// Static collection of timelines\nconst timelines = [];\n\n/**\n * Play animation via start/stop frame labels\n * @class Animator\n * @memberof PIXI.animate\n */\nclass Animator {\n\n    /**\n     * The collection of timelines\n     * @name {Array<PIXI.animate.AnimatorTimeline>} PIXI.animate.Animator#_timelines\n     * @private\n     * @static\n     */\n    static get _timelines() {\n        return timelines;\n    }\n\n    /**\n     * Suffix added to label for a stop.\n     * @name {String} PIXI.animate.Animator.STOP_LABEL\n     * @static\n     * @default \"_stop\"\n     */\n    static get STOP_LABEL() {\n        return \"_stop\";\n    }\n\n    /**\n     * Suffix added to label for a loop.\n     * @name {String} PIXI.animate.Animator.LOOP_LABEL\n     * @static\n     * @default \"_loop\"\n     */\n    static get LOOP_LABEL() {\n        return \"_loop\";\n    }\n\n    /**\n     * Play an animation by frame labels. For instance, play animation sequence from\n     * \"idle\" to \"idle_stop\" or \"idle_loop\". If no event label is provided, will\n     * play the entire duration of the MovieClip.\n     * @method PIXI.animate.Animator#play\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {String|Function} [label] The frame label event to call, if no event is provided\n     *        will use the entire length of the MovieClip. Can also be the callback.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static play(instance, label, callback) {\n        let loop = false;\n        let start, end;\n        const labelIsFunction = typeof label === \"function\";\n        if (label === undefined || labelIsFunction) {\n            start = 0;\n            end = instance.totalFrames - 1;\n            if (labelIsFunction) {\n                callback = label;\n            }\n        } else {\n            start = instance.labelsMap[label];\n            end = instance.labelsMap[label + this.STOP_LABEL];\n            if (end === undefined) {\n                end = instance.labelsMap[label + this.LOOP_LABEL];\n                loop = true;\n            }\n            if (start === undefined) {\n                throw new Error(\"No start label matching '\" + label + \"'\");\n            } else if (end === undefined) {\n                throw new Error(\"No end label matching '\" + label + \"'\");\n            }\n        }\n        return this.fromTo(\n            instance,\n            start,\n            end,\n            loop,\n            callback\n        );\n    }\n\n    /**\n     * Play an animation from the current frame to an end frame or label.\n     * @method PIXI.animate.Animator#to\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {String|Number} end The end frame or label.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static to(instance, end, callback) {\n        return this.fromTo(\n            instance,\n            instance.currentFrame,\n            end,\n            false,\n            callback\n        );\n    }\n\n    /**\n     * Play a MovieClip from a start to end frame.\n     * @method PIXI.animate.Animator#fromTo\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {Number|String} start The starting frame index or label.\n     * @param {Number|String} end The ending frame index or label.\n     * @param {Boolean} [loop=false] If the animation should loop.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static fromTo(instance, start, end, loop, callback) {\n\n        if (typeof start === \"string\") {\n            const startLabel = start;\n            start = instance.labelsMap[startLabel];\n            if (start === undefined) {\n                throw new Error(\"No start label matching '\" + startLabel + \"'\");\n            }\n        }\n        if (typeof end === \"string\") {\n            const endLabel = end;\n            end = instance.labelsMap[endLabel];\n            if (end === undefined) {\n                throw new Error(\"No end label matching '\" + endLabel + \"'\");\n            }\n        }\n        if (start < 0) {\n            throw new Error('Start frame is out of bounds');\n        }\n        if (end >= instance.totalFrames) {\n            throw new Error('End frame is out of bounds');\n        }\n        if (start >= end) {\n            throw new Error('End frame is before start frame');\n        }\n\n        // Stop any animation that's playing\n        this.stop(instance);\n\n        loop = !!loop;\n\n        // Add a new timeline\n        const timeline = AnimatorTimeline.create(\n            instance,\n            start,\n            end,\n            loop,\n            callback\n        );\n        this._timelines.push(timeline);\n\n        // Set the current frame\n        if (instance.currentFrame !== start) {\n            instance.gotoAndPlay(start);\n        } else {\n            instance.play();\n        }\n        return timeline;\n    }\n\n    /**\n     * Stop the animation by instance.\n     * @method PIXI.animate.Animator#stop\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     */\n    static stop(instance) {\n        for (let i = 0, len = this._timelines.length; i < len; i++) {\n            const timeline = this._timelines[i];\n            if (timeline.instance === instance) {\n                this._internalStop(timeline);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Stop all the currently playing animations.\n     * @method PIXI.animate.Animator#stopAll\n     * @static\n     */\n    static stopAll() {\n        for (let i = this._timelines.length - 1; i >= 0; i--) {\n            this._internalStop(this._timelines[i]);\n        }\n    }\n\n    /**\n     * Stop the animation\n     * @method PIXI.animate.Animator#_internalStop\n     * @private\n     * @static\n     * @param {PIXI.animate.AnimatorTimeline} timeline Timeline to stop.\n     */\n    static _internalStop(timeline) {\n        this._timelines.splice(this._timelines.indexOf(timeline), 1);\n        timeline.instance.stop();\n        timeline.destroy();\n    }\n}\n\nmodule.exports = Animator;"]}